#!/usr/bin/env node

import { promises as fs } from "node:fs";
import path from "node:path";
import process from "node:process";
import matter from "gray-matter";
import { marked } from "marked";
import sanitizeHtml from "sanitize-html";
import { z } from "zod";

const rootDir = process.cwd();
const contentDir = path.join(rootDir, "content", "scroll");
const outputDir = path.join(rootDir, "src", "generated");
const outputFile = path.join(outputDir, "scroll-posts.ts");

const frontmatterSchema = z.object({
  title: z.string().trim().min(1),
  excerpt: z.string().trim().min(1),
  date: z
    .string()
    .trim()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "date must be in YYYY-MM-DD format"),
  type: z.enum(["update", "thought-piece"]),
  author: z.string().trim().min(1),
  tags: z.array(z.string().trim().min(1)),
  published: z.boolean(),
  coverImage: z.string().trim().min(1).optional(),
  canonicalUrl: z.string().trim().url().optional(),
});

function isValidCalendarDate(value) {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) return false;

  const [year, month, day] = value.split("-").map(Number);
  const candidate = new Date(Date.UTC(year, month - 1, day));
  return (
    candidate.getUTCFullYear() === year &&
    candidate.getUTCMonth() === month - 1 &&
    candidate.getUTCDate() === day
  );
}

function normalizeSlug(rawSlug) {
  const normalized = rawSlug
    .toLowerCase()
    .replace(/[^a-z0-9-]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .replace(/--+/g, "-");

  if (!normalized) {
    throw new Error(`Could not derive a valid slug from "${rawSlug}"`);
  }

  return normalized;
}

function deriveSlug(fileName) {
  const base = fileName.replace(/\.md$/i, "");
  const match = base.match(/^\d{4}-\d{2}-\d{2}-(.+)$/);
  const rawSlug = match?.[1] ?? base;
  return normalizeSlug(rawSlug);
}

function countReadingMinutes(markdown) {
  const words = markdown.trim().split(/\s+/).filter(Boolean).length;
  return Math.max(1, Math.ceil(words / 220));
}

function sanitizePostHtml(unsafeHtml) {
  return sanitizeHtml(unsafeHtml, {
    allowedTags: [...sanitizeHtml.defaults.allowedTags, "img", "h1", "h2", "h3"],
    allowedAttributes: {
      ...sanitizeHtml.defaults.allowedAttributes,
      img: ["src", "alt", "title"],
      a: ["href", "name", "target", "rel"],
      code: ["class"],
    },
    transformTags: {
      a: (tagName, attribs) => ({
        tagName,
        attribs: {
          ...attribs,
          rel: "noopener noreferrer",
        },
      }),
    },
  });
}

async function generate() {
  let files = [];

  try {
    files = await fs.readdir(contentDir);
  } catch (error) {
    if (error instanceof Error && "code" in error && error.code === "ENOENT") {
      await fs.mkdir(contentDir, { recursive: true });
      files = [];
    } else {
      throw error;
    }
  }

  const markdownFiles = files.filter((file) => file.endsWith(".md")).sort();
  const posts = [];
  const slugSet = new Set();

  for (const fileName of markdownFiles) {
    const filePath = path.join(contentDir, fileName);
    const source = await fs.readFile(filePath, "utf8");
    const { data, content } = matter(source);

    const parsed = frontmatterSchema.safeParse(data);
    if (!parsed.success) {
      throw new Error(
        `Invalid frontmatter in ${path.relative(rootDir, filePath)}: ${parsed.error.issues
          .map((issue) => `${issue.path.join(".")}: ${issue.message}`)
          .join("; ")}`
      );
    }

    if (!isValidCalendarDate(parsed.data.date)) {
      throw new Error(
        `Invalid date in ${path.relative(rootDir, filePath)}: "${parsed.data.date}" is not a real calendar date`
      );
    }

    const slug = deriveSlug(fileName);
    if (slugSet.has(slug)) {
      throw new Error(`Duplicate slug "${slug}" derived from ${fileName}`);
    }
    slugSet.add(slug);

    const rawHtml = marked.parse(content);
    const safeHtml = sanitizePostHtml(rawHtml);

    posts.push({
      slug,
      title: parsed.data.title,
      excerpt: parsed.data.excerpt,
      date: parsed.data.date,
      type: parsed.data.type,
      author: parsed.data.author,
      tags: parsed.data.tags,
      published: parsed.data.published,
      coverImage: parsed.data.coverImage,
      canonicalUrl: parsed.data.canonicalUrl,
      readingTimeMinutes: countReadingMinutes(content),
      html: safeHtml,
    });
  }

  posts.sort((a, b) => {
    if (a.date === b.date) return a.slug.localeCompare(b.slug);
    return a.date < b.date ? 1 : -1;
  });

  const generatedSource = `// This file is auto-generated by scripts/generate-scroll-posts.mjs.
// Do not edit manually.

export type ScrollPostType = "update" | "thought-piece";

export interface ScrollPost {
  slug: string;
  title: string;
  excerpt: string;
  date: string;
  type: ScrollPostType;
  author: string;
  tags: string[];
  published: boolean;
  coverImage?: string;
  canonicalUrl?: string;
  readingTimeMinutes: number;
  html: string;
}

export const scrollPosts: ScrollPost[] = ${JSON.stringify(posts, null, 2)};
`;

  await fs.mkdir(outputDir, { recursive: true });
  await fs.writeFile(outputFile, generatedSource, "utf8");
  process.stdout.write(
    `Generated ${path.relative(rootDir, outputFile)} with ${posts.length} posts\n`
  );
}

generate().catch((error) => {
  process.stderr.write(
    `Failed to generate scroll posts: ${error instanceof Error ? error.message : String(error)}\n`
  );
  process.exit(1);
});
